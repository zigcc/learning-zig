> 原文地址：https://www.openmymind.net/learning_zig/pointers/

# 指针

Zig语言没有垃圾回收机制。内存管理的重任由开发者负责，它直接关乎着应用程序的性能、稳定性和安全性。

我们将从讨论指针开始，这是一个重要的主题，不仅仅是独立讨论的内容，还可以帮助我们从以内存为导向的角度看待程序的数据。如果您已经熟悉指针、堆分配和悬空指针，请随时跳过几个部分，直接前进到[堆内存和内存分配器](https://www.openmymind.net/learning_zig/heap_memory/)的部分，该部分内容更具体涉及 Zig 语言。

以下代码创建了一个 power 为 1 的用户，然后调用 levelUp 函数，该函数会将用户的 power 增加 1。您能猜测输出结果吗？

```zig
const std = @import("std");

pub fn main() void {
	var user = User{
		.id = 1,
		.power = 100,
	};

	// this line has been added
	levelUp(user);
	std.debug.print("User {d} has power of {d}\n", .{user.id, user.power});
}

fn levelUp(user: User) void {
	user.power += 1;
}

pub const User = struct {
	id: u64,
	power: i32,
};
```

这是一个不友好的小把戏，这段代码无法编译：*无法对常量赋值*。我们在第 1 部分中看到，函数参数是常量，因此`user.power += 1;`无效。要修复编译时错误，我们可以将该`levelUp`函数修改为：

```zig
fn levelUp(user: User) void {
	var u = user;
	u.power += 1;
}
```

上述代码虽然能够编译，但程序输出的是*User 1 has power of 100*，尽管我们代码的意图明显是要让`levelUp`将用户的 power 增加到`101`。那么到底发生了什么？

为了更好地理解这个问题，我们可以从内存的角度思考数据，并将变量视为将数据类型与特定内存位置相关联的标签。例如，在`main`中，我们创建一个`User`，这些数据在内存中的可视化可以表示为：

```text
user -> ------------ (id)
        |    1     |
        ------------ (power)
        |   100    |
        ------------
```

有两件重要的事情需要注意。首先，我们的`user`变量指向结构的起始位置。其次，字段是按顺序排列的。请记住，我们`user`也有一个数据类型。该数据类型告诉我们`id`是一个 64 位整数，`power`是一个 32 位整数。有了对数据起始位置的引用和类型信息，编译器可以将`user.power`翻译为：*访问距离起始位置64位的 32 位整数。*这就是变量的 power ，它们引用内存并包含了理解和操作内存所需的类型信息。

默认情况下，Zig 不保证结构体的内存布局。它可以按照字母顺序、按照大小升序或者带有间隔地存储字段，只要能够正确编译即可。这种自由可以启用某些优化。只有当我们声明一个`packed struct`时，我们才能得到关于内存布局的强制性保证。不过，我们对`user`的可视化是合理且有用的。

这是一个略有不同的可视化，它包括了内存地址。该数据开始的内存地址是随机的。这是`user`变量引用的内存地址，也是我们第一个字段`id`的值所在的位置。然而，鉴于这个初始地址，所有后续的地址都有已知的相对地址。由于`id`是 64 位整数，因此需要 8 字节的内存。因此，`power`必须位于 $start_address + 8的位置：

```text
user ->   ------------  (id: 1043368d0)
          |    1     |
          ------------  (power: 1043368d8)
          |   100    |
          ------------
```

为了验证这一点，首先介绍一下取地址运算符：`&`。顾名思义，取地址运算符返回一个变量的地址（它也可以返回函数的地址）。保留现有的`User`定义，尝试编写以下`main`函数：

```zig
pub fn main() void {
	var user = User{
		.id = 1,
		.power = 100,
	};
	std.debug.print("{*}\n{*}\n{*}\n", .{&user, &user.id, &user.power});
}
```

这段代码输出了`user`、`user.id`、和`user.power`的地址。根据平台等差异，可能会得到不同的输出结果，但都会看到`user`和`user.id`的地址相同，而`user.power`的地址偏移量了 8 个字节。输出的结果如下：

```text
learning.User@1043368d0
u64@1043368d0
i32@1043368d8
```

取地址运算符返回一个指向值的指针。指向值的指针是一种特殊的类型。类型`T`的值的地址是`*T`。我们将其发音为*指向 T 类型的指针*。因此，如果我们取`user`的地址，我们将得到`*User`, 或者说是一个指向`User`类型的指针：

```zig
pub fn main() void {
	var user = User{
		.id = 1,
		.power = 100,
	};

	const user_p = &user;
	std.debug.print("{any}\n", .{@TypeOf(user_p)});
}
```

我们最初的目标是通过`levelUp`函数将用户的`power`值增加1 。我们已经让代码编译通过，但当我们打印`power`时，它仍然是原始值。我们将代码更改为在`main`和`levelUp`函数中均打印`user`的地址：

```zig
pub fn main() void {
	const user = User{
		.id = 1,
		.power = 100,
	};

	// added this
	std.debug.print("main: {*}\n", .{&user});

	levelUp(user);
	std.debug.print("User {d} has power of {d}\n", .{user.id, user.power});
}

fn levelUp(user: User) void {
	// add this
	std.debug.print("levelUp: {*}\n", .{&user});
	var u = user;
	u.power += 1;
}
```

如果运行这段代码，会得到两个不同的地址。这意味着在`levelUp`函数中被修改的`user`与在`main`函数中的`user`是不同的。这是因为 Zig 传递了该值的拷贝。这看默认行为的好处之一是调用函数的代码可以确保函数不会修改参数。在很多情况下，这是一个有用的保证。当然，有时，就像在`levelUp`函数中一样，我们希望函数可以修改参数。为了实现这一点，我们需要让`levelUp`函数作用于`main`中的实际`user`，而不是其副本。我们可以通过将`user`的地址传递到函数中来实现这一点：

```zig
const std = @import("std");

pub fn main() void {
	var user = User{
		.id = 1,
		.power = 100,
	};

	// user -> &user
	levelUp(&user);
	std.debug.print("User {d} has power of {d}\n", .{user.id, user.power});
}

// User -> *User
fn levelUp(user: *User) void {
	user.power += 1;
}

pub const User = struct {
	id: u64,
	power: i32,
};
```

我们必须进行两个更改。首先是调用`levelUp` 时使用`user`的地址`&user`，而不是`user`本身。这意味着我们的函数不再接收一个`User`类型参数，而是接收一个`*User`类型参数，这是我们的第二个更改。

现在代码按预期工作了，关于函数参数和我们的内存模型还有许多微妙之处。除了特定的语法之外，这些内容对于 Zig 并不是唯一的。我们在这里探讨的模型是最常见的，一些语言可能只是将许多细节（因此灵活性）隐藏在开发者背后。

## 方法

下面我们将`levelUp`函数写成`User`结构体的一个方法：

```zig
pub const User = struct {
	id: u64,
	power: i32,

	fn levelUp(user: *User) void {
		user.power += 1;
	}
};
```

这就引出了一个问题：我们如何调用带有指针接收器的方法？也许我们需要这样做：`&user.levelUp()`？实际上，你只需正常调用它即可，即`user.levelUp()`. Zig 知道该方法需要一个指针并正确传递该值（通过引用传递）。

我最初选择了一个函数，因为它很明确，因此更容易学习。

## 常量函数参数

我已经暗示过，默认情况下，Zig 会传递一个值的副本（称为“按值传递”）。不久之后，我们将看到现实情况有点更加微妙（提示：具有嵌套对象的复杂值呢？）。

即使只使用简单类型，事实是，Zig可以根据需要以任何方式传递参数，只要它能够保证代码的意图不会受到影响。在我们最初的`levelUp`函数中，参数是一个`User`类型，Zig可以传递用户的副本或对`main.user`的引用，只要它能够保证函数不会对其进行更改。（我知道我们最终确实希望它被更改，但通过将类型设置为`User`，我们告诉编译器我们不希望它被更改）。

这种自由度使得 Zig 能够根据参数类型使用最优策略。占用内存空间较小的类型，例如`User`可以方便地按值传递（即复制）。占用内存空间较大的类型通过引用传递会更佳。Zig 可以使用任何方法，只要保持代码的意图不受影响。在某种程度上，这是通过具有常量函数参数来实现的。

现在你知道函数参数为常量的原因之一了。

也许你在想，即使与复制一个非常小的结构体相比，通过引用传递为什么会更慢。我们将在接下来更清楚地看到这一点，但要点是，当`user`是一个指针时，执行`user.power`会增加一点点开销。编译器必须权衡复制的成本与通过指针间接访问字段的成本。

## 指针到指针

我们之前查看了在`main`函数中`user`的内存是什么样的。现在我们已经更改了`levelUp`函数，那么它的内存会是什么样的呢？：

```text
main:
user -> ------------  (id: 1043368d0)  <---
        |    1     |                      |
        ------------  (power: 1043368d8)  |
        |   100    |                      |
        ------------                      |
                                          |
        .............  empty space        |
        .............  or other data      |
                                          |
levelUp:                                  |
user -> -------------  (*User)            |
        | 1043368d0 |----------------------
        -------------
```

在`levelUp`函数中，`user`是一个指向`User`类型的指针。它的值是一个地址。当然，并不是任意的地址，而是`main.user`
的地址。值得明确的是，在`levelUp`函数中的`user`变量代表了一个具体的值。这个值恰好是一个地址。而且，它是`*User`类型。这一切都非常一致，无论我们是否在谈论指针：变量将类型信息与地址关联起来。指针的唯一特殊之处在于，当我们使用某些语法，例如`user.power`时，Zig会知道`user`是一个指针，会自动跟踪这个地址。

一些编程语言在通过指针访问字段时需要使用不同的符号。

重要的是要理解，`levelUp`函数中的`user`变量本身存在于内存中的某个地址。就像之前所做的一样，我们可以亲自验证这一点：

```zig
fn levelUp(user: *User) void {
	std.debug.print("{*}\n{*}\n", .{&user, user});
	user.power += 1;
}
```

上面打印了`user`变量引用的地址及其值，这个值就是`main`函数中的`user`的地址。

如果`user`的类型是`*User`，那么`&user`呢？它的类型是`**User`, 或者说是一个*指向`User`的指针的指针*。我可以一直这样做，直到内存溢出！

多级间接引用确实有其使用场景，但目前我们并不需要。本节的目的是展示指针并不特殊，它们只是一个值，即一个地址和一个类型。

## 嵌套指针

到目前为止，`User`结构体很简单，仅包含两个整数，因此很容易将其内存可视化，而且当我们谈论“复制”时，没有任何歧义。但当`User`变得更复杂并包含一个指针时会发生什么呢？

```zig
pub const User = struct {
	id: u64,
	power: i32,
	name: []const u8,
};
```

我们已经添加了`name`，它是一个切片。回想一下，切片由长度和指针组成。如果我们使用名字`"Goku"`初始化`user`，它在内存中会是什么样子？

```text
user -> -------------  (id: 1043368d0)
        |     1     |
        -------------  (power: 1043368d8)
        |    100    |
        -------------  (name.len: 1043368dc)
        |     4     |
        -------------  (name.ptr: 1043368e4)
  ------| 1182145c0 |
  |     -------------
  |
  |     .............  empty space
  |     .............  or other data
  |
  --->  -------------  (1182145c0)
        |    'G'    |
        -------------
        |    'o'    |
        -------------
        |    'k'    |
        -------------
        |    'u'    |
        -------------
```

新的`name`字段是一个切片，由`len`和`ptr`字段组成。它们按顺序与所有其他字段一起布局。在64位平台上，`len`和`ptr`都将是64位，即8字节。有趣的是`name.ptr`的值：它是指向内存中的其他位置的地址。

由于我们使用了字符串字面量，`user.name.ptr`将指向二进制文件内部存储所有常量的的特定位置。

类型可以变得比这个更复杂，具有深层嵌套。但不管是简单还是复杂，它们都表现得一样。具体来说，如果我们回到最初的代码，其中`levelUp`函数接收一个`User`类型的参数，而Zig提供了一个副本，那么现在我们有了一个嵌套指针，这将会是什么样子呢？

答案是只会进行浅拷贝。或者只会复制变量直接可寻址的内存。也许看起来`levelUp`会得到一个半成品的`user`副本，可能带有一个无效的`name`。但请记住，指针，如我们的`user.name.ptr`，是一个值，而该值是一个地址。地址的拷贝仍然是相同的地址：

```text
main: user ->    -------------  (id: 1043368d0)
                 |     1     |
                 -------------  (power: 1043368d8)
                 |    100    |
                 -------------  (name.len: 1043368dc)
                 |     4     |
                 -------------  (name.ptr: 1043368e4)
                 | 1182145c0 |-------------------------
levelUp: user -> -------------  (id: 1043368ec)       |
                 |     1     |                        |
                 -------------  (power: 1043368f4)    |
                 |    100    |                        |
                 -------------  (name.len: 1043368f8) |
                 |     4     |                        |
                 -------------  (name.ptr: 104336900) |
                 | 1182145c0 |-------------------------
                 -------------                        |
                                                      |
                 .............  empty space           |
                 .............  or other data         |
                                                      |
                 -------------  (1182145c0)        <---
                 |    'G'    |
                 -------------
                 |    'o'    |
                 -------------
                 |    'k'    |
                 -------------
                 |    'u'    |
                 -------------
```

从上面可以看出，浅拷贝是有效的。由于指针的值是一个地址，复制该值意味着我们获得相同的地址。这对于可变性具有重要意义。我们的函数无法直接更改`main.user`可直接访问的字段，因为它得到了一个副本，但它确实可以访问相同的`name`，那么它可以更改它吗？在这种特定情况下，不可以，因为`name`是一个`const`常量。而且，我们的值"Goku"是一个字符串字面量，它们总是不可变的。我们可以通过下面的例子来进一步理解浅拷贝的含义：

```zig
const std = @import("std");

pub fn main() void {
	var name = [4]u8{'G', 'o', 'k', 'u'};
	var user = User{
		.id = 1,
		.power = 100,
		// slice it, [4]u8 -> []u8
		.name = name[0..],
	};
	levelUp(user);
	std.debug.print("{s}\n", .{user.name});
}

fn levelUp(user: User) void {
	user.name[2] = '!';
}

pub const User = struct {
	id: u64,
	power: i32,
	// []const u8 -> []u8
	name: []u8
};
```

上面的代码会打印出"Go!u"。我们不得不将`name`的类型从`[]const u8`更改为`[]u8`，并且不再使用总是不可变的字符串字面量，而是创建一个数组并对其进行切片。有些人可能会在这里看到不一致之处。按值传递可以防止函数更改直接字段，但不能防止后面带有指针值的字段的更改。如果我们确实希望`name`是不可变的，我们应该将其声明为`[]const u8`而不是`[]u8`。

一些编程语言可能有不同的实现方式，但许多编程语言确实与这个原理非常接近，或者工作方式完全相同。虽然所有这些可能看起来有点深奥，但它们是日常编程的基础。好消息是，你可以使用简单的示例和代码片段来掌握这些概念，随着系统其他部分的复杂性增加，这些原理并不会变得更加复杂。

## 递归结构

有时您需要一个结构是递归的。保持我们现有的代码，向`User`结构体中添加一个可选的类型为`?User`的manager变量。同时创建两个`Users`，并将一个赋值给另一个manager：

```zig
const std = @import("std");

pub fn main() void {
	const leto = User{
		.id = 1,
		.power = 9001,
		.manager = null,
	};

	const duncan = User{
		.id = 1,
		.power = 9001,
		.manager = leto,
	};

	std.debug.print("{any}\n{any}", .{leto, duncan});
}

pub const User = struct {
	id: u64,
	power: i32,
	manager: ?User,
};
```

这段代码无法编译，因为存在循环依赖问题，即*struct 'learning.User' depends on itself*。这个问题的根本原因是每种类型都必须在编译时具有已知的大小，而递归结构会导致无限大小的类型。

当我们添加`name`字段时，并没有遇到这个问题，即使名称的长度可以不同。问题不在于值的大小，而在于类型本身的大小。Zig需要知道类型的大小以执行我们上面讨论的所有操作，比如根据字段的偏移位置访问它们。`name`是一个切片，即`[]const u8`，它的大小是已知的：`len`字段占16字节 - 8字节，`ptr`字段占8字节。

你可能会认为这个问题会出现在任何可选类型或联合类型中。但对于可选类型和联合类型，最大可能的大小是已知的，Zig可以使用它们。而递归结构没有这种上限，结构可能递归一次、两次或数百万次。这个次数会从一个`User`到另一个`User`变化，并且在编译时是未知的。

我们在`name`字段中已经看到了答案：使用指针。指针始终占用`usize`字节。在64位平台上，这是8字节。就像实际的名字“Goku”并没有与我们的`user`一起存储一样，使用指针意味着manager不再与`user`的内存布局绑定在一起。

```zig
const std = @import("std");

pub fn main() void {
	const leto = User{
		.id = 1,
		.power = 9001,
		.manager = null,
	};

	const duncan = User{
		.id = 1,
		.power = 9001,
		// changed from leto -> &leto
		.manager = &leto,
	};

	std.debug.print("{any}\n{any}", .{leto, duncan});
}

pub const User = struct {
	id: u64,
	power: i32,
	// changed from ?const User -> ?*const User
	manager: ?*const User,
};
```

你可能永远不需要一个递归结构，但这并不是关于如何数据建模，而是关于理解指针和内存模型，以及更好地理解编译器的工作原理。理解这些概念可以帮助你更深入地了解编译器的工作方式和内存管理。

许多开发者在处理指针时感到困惑，它们可能显得不像整数、字符串或`User`那样具体。虽然你不必完全理解这些概念就能继续前进，但掌握它们是值得的，不仅仅是为了Zig。在像Ruby、Python和JavaScript这样的语言中，这些细节可能被隐藏起来，而在C#、Java和Go等语言中，它们也存在，影响着你编写代码的方式以及代码的运行方式。因此，请花些时间，尝试一些示例，添加调试打印语句来查看变量和它们的地址。你探索得越多，就会变得越清晰。